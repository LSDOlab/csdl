from csdl.rep.graph_representation import GraphRepresentation
from csdl.lang.hybrid_implicit_operation import HybridImplicitOperation
from typing import List, Dict, Union
import numpy as np


# TODO: enable nested operations with namespaces
# This function only needs to be called once at compile time
def collect_hybrid_implicit_operations(
    rep: GraphRepresentation,
    mode: str = '',
) -> Dict[str, HybridImplicitOperation]:
    operations = rep.operation_nodes()
    hybrid_operations: List[HybridImplicitOperation] = list(
        filter(lambda x: isinstance(x, HybridImplicitOperation),
               operations))
    d = {h.name: h for h in hybrid_operations}
    if mode == 'implicit' or mode == 'explicit':
        return {k: v for k, v in d.items() if v.mode == mode}
    return d


# This is an example of how to set tolerances at run time after
# each iteration; you can call this within a loop that iterates over
# names and tolerances generated by SURF; you should only call this
# function on hybrid implicit operations collected using mode ==
# 'implicit'
def set_hybrid_tolerance(
    op_dict: Dict[str, HybridImplicitOperation],
    op_name: str,
    tol: float,
):
    op_dict[op_name].set_tolerance(tol)


# This is an example of how to set the initial guess at run time after
# each iteration; you can call this within a loop that iterates over
# names and tolerances generated by SURF; you should only call this
# function on hybrid implicit operations collected using mode ==
# 'explicit'
def set_initial_guess(
    op_dict: Dict[str, HybridImplicitOperation],
    op_name: str,
    var_name: str,
    val: Union[int, float, np.ndarray],
):
    op_dict[op_name].sim[var_name] = val
