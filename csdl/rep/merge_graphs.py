try:
    from csdl.lang.model import Model
except ImportError:
    pass
try:
    from csdl.lang.subgraph import Subgraph
except ImportError:
    pass
import imp
from csdl.rep.model_node import ModelNode
from csdl.rep.ir_node import IRNode
from csdl.rep.variable_node import VariableNode
from csdl.rep.operation_node import OperationNode
from csdl.utils.prepend_namespace import prepend_namespace
from typing import List, Tuple
from networkx import DiGraph, compose

from csdl.rep.variable_node import VariableNode
from typing import Dict


def merge_graphs(graph: DiGraph, namespace: str = ''):
    """
    Copy nodes and edges from graphs in submodels into the graph for the
    main model.
    """
    model_nodes: Dict[str, ModelNode] = {prepend_namespace(namespace, node.name): node for node in list(filter(lambda x: isinstance(x, ModelNode), child_graph.nodes())),}
    for mn in model_nodes:
        child_graph = DiGraph(mn.graph.copy())
        var_nodes: Dict[str, VariableNode] = {prepend_namespace(namespace, node.var.name): node for node in list(filter(lambda x: isinstance(x, VariableNode), child_graph.nodes()))}
        for k,v in mn.model.promoted_names_to_unpromoted_names.items():
            src_node_names = list(filter(lambda x: x in mn.model.promoted_source_shapes.keys(), v))
            tgt_node_names = list(filter(lambda x: x in mn.model.promoted_target_shapes.keys(), v))
            src_node: VariableNode | None = None
            tgt_node: list[VariableNode] = []
            if len(src_node_names) > 0:
                src_node = var_nodes[src_node_names[0]]
            if len(tgt_node_names) > 0:
                tgt_nodes = [var_nodes[tnn] for tnn in tgt_node_names]
            if src_node is not None and tgt_node != []:
                # combine source node and target nodes
                pass
            elif src_node is None:
                # combine target nodes
                pass
            elif tgt_node == []:
                pass





    # assign promoted namespace to each VariableNode
    # and OperationNode? -- each Operation has a unique,
    # autogenerated name

    # performing recursion from the top down,
    # add namespace to each VariableNode in each ModelNode in graph
    # this will give us unpromoted names for each variable

    # in main model:
    # use unpromoted_to_promoted dict to get promoted namespace

    # promoted_to_unpromoted


    # merged_graph = Compose(merged_graph, graph)

    model_nodes: List[ModelNode] = list(
        filter(lambda x: isinstance(x, ModelNode), graph.nodes()))
    nodes: List[Tuple[IRNode, IRNode]] = []
    edges: List[Tuple[IRNode, IRNode]] = []
    if len(model_nodes) == 0:
        return graph
    for mn in model_nodes:
        g = mn.graph
        merge_graphs(g)
        nodes.extend(list(g.nodes()))
        edges.extend(list(g.edges()))
    graph.add_nodes_from(nodes)
    graph.add_edges_from(edges)
    graph.remove_nodes_from(model_nodes)
