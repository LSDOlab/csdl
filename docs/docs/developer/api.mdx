---
title: Developer API
---

------------------------------------------------------------------------


<a id="csdl.core.model"></a>

# csdl.core.model

<a id="csdl.core.model.ImplicitOperationFactory"></a>

## ImplicitOperationFactory Objects

```python
class ImplicitOperationFactory(object)
```

<a id="csdl.core.model.ImplicitOperationFactory.__init__"></a>

### \_\_init\_\_

```python
def __init__(parent, model)
```

<a id="csdl.core.model.ImplicitOperationFactory.declare_state"></a>

### declare\_state

```python
def declare_state(state: str, bracket: Tuple[Union[int, float, np.ndarray],
                       Union[int, float, np.ndarray]] = None, *, residual: str)
```

<a id="csdl.core.model.ImplicitOperationFactory.__call__"></a>

### \_\_call\_\_

```python
def __call__(*arguments: Variable, *, expose: List[str] = [], defaults: Dict[str, Union[int, float, np.ndarray]] = dict())
```

<a id="csdl.core.model.build_symbol_table"></a>

### build\_symbol\_table

```python
def build_symbol_table(symbol_table, node)
```

<a id="csdl.core.model.build_clean_dag"></a>

### build\_clean\_dag

```python
def build_clean_dag(registered_outputs)
```

<a id="csdl.core.model._run_front_end_and_middle_end"></a>

### \_run\_front\_end\_and\_middle\_end

```python
def _run_front_end_and_middle_end(run_front_end: Callable) -> Callable
```

This function replaces ``Model.setup`` with a new method that calls
``Model.setup`` and performs the necessary steps to determine
execution order and construct and add the appropriate subsystems.

The new method is the core of the ``csdl`` package. This function
analyzes the Directed Acyclic Graph (DAG) and sorts expressions.

<a id="csdl.core.model._CompilerFrontEndMiddleEnd"></a>

## \_CompilerFrontEndMiddleEnd Objects

```python
class _CompilerFrontEndMiddleEnd(type)
```

<a id="csdl.core.model._CompilerFrontEndMiddleEnd.__new__"></a>

### \_\_new\_\_

```python
def __new__(cls, name, bases, attr)
```

<a id="csdl.core.model.Model"></a>

## Model Objects

```python
class Model(, metaclass=_CompilerFrontEndMiddleEnd)
```

<a id="csdl.core.model.Model.__init__"></a>

### \_\_init\_\_

```python
def __init__(**kwargs)
```

<a id="csdl.core.model.Model.initialize"></a>

### initialize

```python
def initialize()
```

User defined method to declare parameter values. Parameters are
compile time constants (neither inputs nor outputs to the model)
and cannot be updated at runtime. Parameters are intended to
make a ``Model`` subclass definition generic, and therefore
reusable. The example below shows how a ``Model`` subclass
definition uses parameters and how the user can set parameters
when constructing the example ``Model`` subclass.

**Example**


```py
class Example(Model):
    def initialize(self):
        self.parameters.declare('num_times', types=int)
        self.parameters.declare('step_size', types=float)
        self.parameters.declare('surface', types=dict)

    def define(self):
        num_times = self.parameters['num_times']
        step_size = self.parameters['step_size']
        surface = self.parameters['surface']
        name = surface['name'] # str
        symmetry = surface['symmetry'] # bool
        mesh = surface['mesh'] # numpy array

        # define runtime behavior...

    surface = {
        'name': 'wing',
        'symmetry': False,
        'mesh': mesh,
    }

    # compile using Simulator imported from back end...
    sim = Simulator(
        Example(
            num_times=100,
            step_size=0.1,
            surface=surface,
        ),
    )
```

<a id="csdl.core.model.Model.define"></a>

### define

```python
def define()
```

User defined method to define runtime behavior.
Note: the user never _calls_ this method. Only the `Simulator`
class constructor calls this method.

**Example**

```py
class Example(Model):
    def define(self):
        self.create_input('x')
        m = 5
        b = 3
        y = m*x + b
        self.register_output('y', y)

# compile using Simulator imported from back end...
sim = Simulator(Example())
sim['x'] = -3/5
sim.run()
print(sim['y']) # expect 0
```

<a id="csdl.core.model.Model._redefine"></a>

### \_redefine

```python
def _redefine(expose: List[str])
```

Remove edges so that we can update the graph.
This is *only* used when exposing intermediate variables for a
composite residual.

<a id="csdl.core.model.Model.print_var"></a>

### print\_var

```python
def print_var(var: Variable)
```

Print *runtime* value during execution. Note that ``print_var``
should only be used for debugging, as it does have a performance
impact. Note that Python's ``print`` function will print the
CSDL compile time ``Variable`` object information, and will have
no effect on run time execution.

**Example**

```python
y = csdl.sin(x)
print(y) # will print compile time information about y
self.print_var(y) # will print run time value of y
```

<a id="csdl.core.model.Model.add_objective"></a>

### add\_objective

```python
def add_objective(name, ref=None, ref0=None, index=None, units=None, adder=None, scaler=None, parallel_deriv_color=None, cache_linear_solution=False)
```

Declare the objective for the optimization problem. Objective
must be a scalar variable.

<a id="csdl.core.model.Model.add_design_variable"></a>

### add\_design\_variable

```python
def add_design_variable(name, lower=None, upper=None, ref=None, ref0=None, indices=None, adder=None, scaler=None, units=None, parallel_deriv_color=None, cache_linear_solution=False)
```

Add a design variable to the optimization problem. The design
variable must be an ``Input``. This will signal to the optimizer
that it is responsible for updating the input variable.

<a id="csdl.core.model.Model.add_constraint"></a>

### add\_constraint

```python
def add_constraint(name, lower=None, upper=None, equals=None, ref=None, ref0=None, adder=None, scaler=None, units=None, indices=None, linear=False, parallel_deriv_color=None, cache_linear_solution=False)
```

Add a constraint to the optimization problem.

<a id="csdl.core.model.Model.connect"></a>

### connect

```python
def connect(a: str, b: str)
```

<a id="csdl.core.model.Model.declare_variable"></a>

### declare\_variable

```python
def declare_variable(name: str, val=1.0, shape=(1, ), src_indices=None, flat_src_indices=None, units=None, desc='', tags=None, shape_by_conn=False, copy_shape=None, distributed=None) -> Variable
```

Declare an input to use in an expression.

An input can be an output of a child ``System``. If the user
declares an input that is computed by a child ``System``, then
the call to ``self.declare_variable`` must appear after the call to
``self.add``.

**Parameters**

name: str
    Name of variable in CSDL to be used as a local input that
    takes a value from a parent model, child model, or
    previously registered output within the model.
shape: Tuple[int]
    Shape of variable
val: Number or ndarray
    Default value for variable

**Returns**

DocInput
    An object to use in expressions

<a id="csdl.core.model.Model.create_input"></a>

### create\_input

```python
def create_input(name, val=1.0, shape=(1, ), units=None, desc='', tags=None, shape_by_conn=False, copy_shape=None, distributed=None) -> Input
```

Create an input to the main model, whose value remains constant
during model evaluation.

**Parameters**

name: str
    Name of variable in CSDL
shape: Tuple[int]
    Shape of variable
val: Number or ndarray
    Value for variable during first model evaluation

**Returns**

Input
    An object to use in expressions

<a id="csdl.core.model.Model.create_output"></a>

### create\_output

```python
def create_output(name, val=1.0, shape=(1, ), units=None, res_units=None, desc='', lower=None, upper=None, ref=1.0, ref0=0.0, res_ref=1.0, tags=None, shape_by_conn=False, copy_shape=None, distributed=None) -> Concatenation
```

Create a value that is computed explicitly, either through
indexed assignment, or as a fixed point iteration.

**Example**

```python
x = self.create_output('x', shape=(5,3,2))
x[:, :, 0] = a
x[:, :, 1] = b
```

**Parameters**

name: str
    Name of variable in CSDL
shape: Tuple[int]
    Shape of variable

**Returns**

Concatenation
    An object to use in expressions

<a id="csdl.core.model.Model.register_output"></a>

### register\_output

```python
def register_output(name: str, var: Variable) -> Output
```

Register ``var`` as an output of the ``Model``.
When adding subsystems, each of the submodel's inputs requires
a call to ``register_output`` prior to the call to
``add``.

**Parameters**

name: str
    Name of variable in CSDL

var: Variable
    Variable that computes output

**Returns**

Variable
    Variable that computes output

<a id="csdl.core.model.Model.add"></a>

### add

```python
def add(submodel, name: str = '', promotes: List[str] = None, promotes_inputs: List[str] = None, promotes_outputs: List[str] = None)
```

Add a submodel to the ``Model``.

``self.add`` call must be preceded by a call to
``self.register_output`` for each of the submodel's inputs,
and followed by ``self.declare_variable`` for each of the
submodel's outputs.

**Parameters**

name: str
    Name of submodel
submodel: System
    Subsystem to add to `Model`
promotes: List
    Variables to promote
promotes_inputs: List
    Inputs to promote
promotes_outputs: List
    Outputs to promote

**Returns**

System
    Subsystem to add to `Model`

<a id="csdl.core.model.Model._bracketed_search"></a>

### \_bracketed\_search

```python
def _bracketed_search(*arguments: Variable, *, states: List[str], residuals: List[str], model, brackets: Dict[str, Tuple[Union[int, float, np.ndarray],
                                  Union[int, float, np.ndarray]]], expose: List[str] = [], maxiter: int = 100)
```

Create an implicit operation whose residuals are defined by a
`Model`.
An implicit operation is an operation that solves an equation
$f(x,y)=0$ for $y$, given some value of $x$.
CSDL solves $f(x,y)=0$ by defining a residual $r=f(x,y)$ and
updating $y$ until $r$ converges to zero.

**Parameters**

`arguments: List[Variable]`

    List of variables to use as arguments for the implicit
    operation.
    Variables must have the same name as a declared variable
    within the `model`'s class definition.

    :::note
    The declared variable _must_ be declared within `model`
    _and not_ promoted from a child submodel.
    :::

`states: List[str]`

    Names of states to compute using the implicit operation.
    The order of the names of these states corresponds to the
    order of the output variables returned by
    `implicit_operation`.
    The order of the names in `states` must also match the order
    of the names of the residuals associated with each state in
    `residuals`.

    :::note
    The declared variable _must_ be declared within `model`
    _and not_ promoted from a child submodel.
    :::

`residuals: List[str]`

    The residuals associated with the states.
    The name of each residual must match the name of a
    registered output in `model`.

    :::note
    The registered output _must_ be registered within `model`
    _and not_ promoted from a child submodel.
    :::

`model: Model`

    The `Model` object to use to define the residuals.
    Residuals may be defined via functional composition and/or
    hierarchical composition.

    :::note
    _Any_ `Model` object may be used to define residuals for an
    implicit operation
    :::

`nonlinear_solver: NonlinearSolver`

    The nonlinear solver to use to converge the residuals

`linear_solver: LinearSolver`

    The linear solver to use to solve the linear system

`expose: List[str]`

    List of intermediate variables inside `model` that are
    required for computing residuals to which it is desirable
    to have access outside of the implicit operation.

    For example, if a trajectory is computed using time marching
    and a residual is computed from the final state of the
    trajectory, it may be desirable to plot that trajectory
    after the conclusion of a simulation, e.g. after an
    iteration during an optimization process.

    :::note
    The variable names in `expose` may be any name within the
    model hierarchy defined in `model`, but the variable names
    in `expose` are neither declared variables, nor registered
    outputs in `model`, although they may be declared
    variables/registered outputs in a submodel (i.e. they are
    neither states nor residuals in the, implicit operation).
    :::

**Returns**

`Tuple[Ouput]`

    Variables to use in this `Model`.
    The variables are named according to `states` and `expose`,
    and are returned in the same order in which they are
    declared.
    For example, if `states=['a', 'b', 'c']` and
    `expose=['d', 'e', 'f']`, then the outputs
    `a, b, c, d, e, f` in
    `a, b, c, d, e, f = self.implcit_output(...)`
    will be named
    `'a', 'b', 'c', 'd', 'e', 'f'`, respectively.
    This enables use of exposed intermediate variables (in
    addition to the states computed by converging the
    residuals) from `model` in this `Model`.
    Unused outputs will be ignored, so
    `a, b, c = self.implcit_output(...)`
    will make the variables declared in `expose` available for
    recording/analysis and promotion/connection, but they will
    be unused by this `Model`.
    Note that these variables are already registered as outputs
    in this `Model`, so there is no need to call
    `Model.register_output` for any of these variables.

<a id="csdl.core.model.Model._implicit_operation"></a>

### \_implicit\_operation

```python
def _implicit_operation(*arguments: Variable, *, states: List[str], residuals: List[str], model, nonlinear_solver: NonlinearSolver, linear_solver: LinearSolver = None, expose: List[str] = [], defaults: Dict[str, Union[int, float, np.ndarray]] = dict())
```

Create an implicit operation whose residuals are defined by a
`Model`.
An implicit operation is an operation that solves an equation
$f(x,y)=0$ for $y$, given some value of $x$.
CSDL solves $f(x,y)=0$ by defining a residual $r=f(x,y)$ and
updating $y$ until $r$ converges to zero.

**Parameters**

`arguments: List[Variable]`

    List of variables to use as arguments for the implicit
    operation.
    Variables must have the same name as a declared variable
    within the `model`'s class definition.

    :::note
    The declared variable _must_ be declared within `model`
    _and not_ promoted from a child submodel.
    :::

`states: List[str]`

    Names of states to compute using the implicit operation.
    The order of the names of these states corresponds to the
    order of the output variables returned by
    `implicit_operation`.
    The order of the names in `states` must also match the order
    of the names of the residuals associated with each state in
    `residuals`.

    :::note
    The declared variable _must_ be declared within `model`
    _and not_ promoted from a child submodel.
    :::

`residuals: List[str]`

    The residuals associated with the states.
    The name of each residual must match the name of a
    registered output in `model`.

    :::note
    The registered output _must_ be registered within `model`
    _and not_ promoted from a child submodel.
    :::

`model: Model`

    The `Model` object to use to define the residuals.
    Residuals may be defined via functional composition and/or
    hierarchical composition.

    :::note
    _Any_ `Model` object may be used to define residuals for an
    implicit operation
    :::

`nonlinear_solver: NonlinearSolver`

    The nonlinear solver to use to converge the residuals

`linear_solver: LinearSolver`

    The linear solver to use to solve the linear system

`expose: List[str]`

    List of intermediate variables inside `model` that are
    required for computing residuals to which it is desirable
    to have access outside of the implicit operation.

    For example, if a trajectory is computed using time marching
    and a residual is computed from the final state of the
    trajectory, it may be desirable to plot that trajectory
    after the conclusion of a simulation, e.g. after an
    iteration during an optimization process.

    :::note
    The variable names in `expose` may be any name within the
    model hierarchy defined in `model`, but the variable names
    in `expose` are neither declared variables, nor registered
    outputs in `model`, although they may be declared
    variables/registered outputs in a submodel (i.e. they are
    neither states nor residuals in the, implicit operation).
    :::

**Returns**

`Tuple[Ouput]`

    Variables to use in this `Model`.
    The variables are named according to `states` and `expose`,
    and are returned in the same order in which they are
    declared.
    For example, if `states=['a', 'b', 'c']` and
    `expose=['d', 'e', 'f']`, then the outputs
    `a, b, c, d, e, f` in
    `a, b, c, d, e, f = self.implcit_output(...)`
    will be named
    `'a', 'b', 'c', 'd', 'e', 'f'`, respectively.
    This enables use of exposed intermediate variables (in
    addition to the states computed by converging the
    residuals) from `model` in this `Model`.
    Unused outputs will be ignored, so
    `a, b, c = self.implcit_output(...)`
    will make the variables declared in `expose` available for
    recording/analysis and promotion/connection, but they will
    be unused by this `Model`.
    Note that these variables are already registered as outputs
    in this `Model`, so there is no need to call
    `Model.register_output` for any of these variables.

<a id="csdl.core.model.Model._something"></a>

### \_something

```python
def _something(model, arguments, states, residuals, expose: List[str] = [])
```

<a id="csdl.core.model.Model._return_implicit_outputs"></a>

### \_return\_implicit\_outputs

```python
def _return_implicit_outputs(model, op, arguments, states, residuals, expose)
```

<a id="csdl.core.model.Model.create_implicit_operation"></a>

### create\_implicit\_operation

```python
def create_implicit_operation(model)
```

<a id="csdl.core.model.Model.__enter__"></a>

### \_\_enter\_\_

```python
def __enter__()
```

<a id="csdl.core.model.Model.__exit__"></a>

### \_\_exit\_\_

```python
def __exit__(type, value, traceback)
```

<a id="csdl.core.model.Model.create_submodel"></a>

### create\_submodel

```python
@contextmanager
def create_submodel(name: str)
```

Create a ``Model`` object and add as a submodel, promoting all
inputs and outputs.
For use in ``with`` contexts.
NOTE: Only use if planning to promote all varaibales within
child ``Model`` object.

**Parameters**

name: str
    Name of new child ``Model`` object

**Returns**

Model
    Child ``Model`` object whose variables are all promoted

<a id="csdl.core.model.Model.visualize_sparsity"></a>

### visualize\_sparsity

```python
def visualize_sparsity()
```

Visualize the sparsity pattern of jacobian for this model

<a id="csdl.core.model.Model.visualize_graph"></a>

### visualize\_graph

```python
def visualize_graph()
```

<a id="csdl.core.model.add_diag_implicit"></a>

### add\_diag\_implicit

```python
def add_diag_implicit(A, variables, implicit_outputs, indices=dict(), implicit_nodes=dict(), p=0, indent='')
```

<a id="csdl.core.model.add_off_diag_implicit"></a>

### add\_off\_diag\_implicit

```python
def add_off_diag_implicit(A, indices, implicit_nodes)
```

<a id="csdl.core.model.add_diag"></a>

### add\_diag

```python
def add_diag(A, nodes, indices=dict(), implicit_nodes=dict(), p=0, indent='')
```

<a id="csdl.core.model.add_off_diag"></a>

### add\_off\_diag

```python
def add_off_diag(A, model, indices)
```




<a id="csdl.core.simulator_base"></a>

# csdl.core.simulator\_base

<a id="csdl.core.simulator_base._ReprClass"></a>

## \_ReprClass Objects

```python
class _ReprClass(object)
```

Class for defining objects with a simple constant string __repr__.

This is useful for constants used in arg lists when you want them to appear in
automatically generated source documentation as a certain string instead of python's
default representation.

<a id="csdl.core.simulator_base._ReprClass.__init__"></a>

### \_\_init\_\_

```python
def __init__(repr_string)
```

Inititialize the __repr__ string.

**Parameters**

repr_string : str
    The string to be returned by __repr__

<a id="csdl.core.simulator_base._ReprClass.__repr__"></a>

### \_\_repr\_\_

```python
def __repr__()
```

Return our _repr_string.

**Returns**

str
    Whatever string we were initialized with.

<a id="csdl.core.simulator_base.SimulatorBase"></a>

## SimulatorBase Objects

```python
class SimulatorBase()
```

A class that can be used as a base class for the ``Simulator`` class
that a CSDL compiler back end would provide.
This class is only here so that CSDL users and CSDL compiler back end
developers have API documentation.
CSDL users are not to use the ``SimulatorBase`` class provided by
``csdl``, only the ``Simulator`` class provided by the CSDL compiler
back end of choice.

<a id="csdl.core.simulator_base.SimulatorBase.__init__"></a>

### \_\_init\_\_

```python
def __init__(model, reorder=False)
```

Constructor.

<a id="csdl.core.simulator_base.SimulatorBase.__getitem__"></a>

### \_\_getitem\_\_

```python
def __getitem__(key)
```

Method to get variable values before or after a simulation run

<a id="csdl.core.simulator_base.SimulatorBase.__setitem__"></a>

### \_\_setitem\_\_

```python
def __setitem__(key, val)
```

Method to set values for variables by name

<a id="csdl.core.simulator_base.SimulatorBase.run"></a>

### run

```python
def run()
```

Method to run a simulation once. This method should be
implemented so that it can be called repeatedly to solve an
optimization problem.

<a id="csdl.core.simulator_base.SimulatorBase.compute_total_derivatives"></a>

### compute\_total\_derivatives

```python
def compute_total_derivatives() -> OrderedDict
```

Method to compute total derivatives for use by an optimizer

**Returns**

    `OrderedDict[str, Any]`

<a id="csdl.core.simulator_base.SimulatorBase.compute_exact_hessian"></a>

### compute\_exact\_hessian

```python
def compute_exact_hessian()
```

Method to compute exact Hessian

<a id="csdl.core.simulator_base.SimulatorBase.check_partials"></a>

### check\_partials

```python
def check_partials()
```

Method to compute the error for all partial derivatives of all
operations within the model.

**Returns**

An object that is compatible with `assert_check_partials`

<a id="csdl.core.simulator_base.SimulatorBase.assert_check_partials"></a>

### assert\_check\_partials

```python
def assert_check_partials(result, atol=1e-8, rtol=1e-8)
```

Method to check that the partial derivatives of all operations
are within a specified tolerance.

**Parameters**

`result`: Return type of `check_partials`

<a id="csdl.core.simulator_base.SimulatorBase.visualize_implementation"></a>

### visualize\_implementation

```python
def visualize_implementation()
```

A method for the back end to provide its own visualization of
the model.

<a id="csdl.core.simulator_base.SimulatorBase.objective"></a>

### objective

```python
def objective() -> Dict[str, Any]
```

Method to provide optimizer with objective

<a id="csdl.core.simulator_base.SimulatorBase.design_variables"></a>

### design\_variables

```python
def design_variables() -> OrderedDict
```

Method to provide optimizer with design variables
**Returns**

    `OrderedDict[str, Dict[str, Any]]`

<a id="csdl.core.simulator_base.SimulatorBase.constraints"></a>

### constraints

```python
def constraints() -> OrderedDict
```

Method to provide optimizer with constraints

**Returns**

    `OrderedDict[str, Dict[str, Any]]`

<a id="csdl.core.simulator_base.SimulatorBase.implicit_outputs"></a>

### implicit\_outputs

```python
def implicit_outputs()
```

Method to provide optimizer with implicit_outputs

<a id="csdl.core.simulator_base.SimulatorBase.residuals"></a>

### residuals

```python
def residuals()
```

Method to provide optimizer with residuals

<a id="csdl.core.simulator_base.SimulatorBase.objective_gradient"></a>

### objective\_gradient

```python
def objective_gradient() -> OrderedDict
```

Method to provide optimizer with total derivative of objective
with respect to design variables

**Returns**

    `OrderedDict[Tuple[str, str], Any]`

<a id="csdl.core.simulator_base.SimulatorBase.constraint_jacobian"></a>

### constraint\_jacobian

```python
def constraint_jacobian() -> OrderedDict
```

Method to provide optimizer with total derivatives of
constraints with respect to design variables

**Returns**

    `OrderedDict[Tuple[str, str], Any]`

<a id="csdl.core.simulator_base.SimulatorBase.residuals_jacobian"></a>

### residuals\_jacobian

```python
def residuals_jacobian()
```

Method to provide optimizer with total derivatives of
residuals with respect to design variables




<a id="csdl.core.custom_explicit_operation"></a>

# csdl.core.custom\_explicit\_operation

<a id="csdl.core.custom_explicit_operation.CustomExplicitOperation"></a>

## CustomExplicitOperation Objects

```python
class CustomExplicitOperation(CustomOperation)
```

<a id="csdl.core.custom_explicit_operation.CustomExplicitOperation.compute"></a>

### compute

```python
def compute(inputs, outputs)
```

Define outputs as an explicit function of the inputs

**Example**

.. code-block:: python

    def compute(self, inputs, outputs):
        outputs['L'] = 1/2 * inputs['Cl'] * inputs['rho'] * inputs['V']**2 * inputs['S']
        outputs['D'] = 1/2 * inputs['Cd'] * inputs['rho'] * inputs['V']**2 * inputs['S']

<a id="csdl.core.custom_explicit_operation.CustomExplicitOperation.compute_derivatives"></a>

### compute\_derivatives

```python
def compute_derivatives(inputs, derivatives)
```

User defined method to compute partial derivatives for this
operation

**Example**

.. code-block:: python

    def compute(self, inputs, outputs):
        outputs['L'] = 1/2 * inputs['Cl'] * inputs['rho'] * inputs['V']**2 * inputs['S']
        outputs['D'] = 1/2 * inputs['Cd'] * inputs['rho'] * inputs['V']**2 * inputs['S']

    def compute_derivatives(self, inputs, derivatives):
        derivatives['L', 'Cl'] = 1/2 * inputs['rho'] * inputs['V']**2 * inputs['S']
        derivatives['L', 'rho'] = 1/2 * inputs['Cl'] * inputs['V']**2 * inputs['S']
        derivatives['L', 'V'] = inputs['Cl'] * inputs['rho'] * inputs['V'] * inputs['S']
        derivatives['L', 'S'] = 1/2 * inputs['Cl'] * inputs['rho'] * inputs['V']**2

        derivatives['D', 'Cd'] = 1/2 * inputs['rho'] * inputs['V']**2 * inputs['S']
        derivatives['D', 'rho'] = 1/2 * inputs['Cd'] * inputs['V']**2 * inputs['S']
        derivatives['D', 'V'] = inputs['Cd'] * inputs['rho'] * inputs['V'] * inputs['S']
        derivatives['D', 'S'] = 1/2 * inputs['Cd'] * inputs['rho'] * inputs['V']**2

<a id="csdl.core.custom_explicit_operation.CustomExplicitOperation.compute_jacvec_product"></a>

### compute\_jacvec\_product

```python
def compute_jacvec_product(inputs, d_inputs, d_outputs, mode)
```

[Optional] Implement partial derivatives by computing a
matrix-vector product

*Example*

.. code-block:: python

    def compute(self, inputs, outputs):
        outputs['area'] = inputs['length'] * inputs['width']

    def compute_jacvec_product(self, inputs, d_inputs, d_outputs, mode):
        if mode == 'fwd':
            if 'area' in d_outputs:
                if 'length' in d_inputs:
                    d_outputs['area'] += inputs['width'] * d_inputs['length']
                if 'width' in d_inputs:
                    d_outputs['area'] += inputs['length'] * d_inputs['width']
        elif mode == 'rev':
            if 'area' in d_outputs:
                if 'length' in d_inputs:
                    d_inputs['length'] += inputs['width'] * d_outputs['area']
                if 'width' in d_inputs:
                    d_inputs['width'] += inputs['length'] * d_outputs['area']




<a id="csdl.core.custom_implicit_operation"></a>

# csdl.core.custom\_implicit\_operation

<a id="csdl.core.custom_implicit_operation.CustomImplicitOperation"></a>

## CustomImplicitOperation Objects

```python
class CustomImplicitOperation(CustomOperation)
```

<a id="csdl.core.custom_implicit_operation.CustomImplicitOperation.__init__"></a>

### \_\_init\_\_

```python
def __init__(*args, **kwargs)
```

<a id="csdl.core.custom_implicit_operation.CustomImplicitOperation.evaluate_residuals"></a>

### evaluate\_residuals

```python
def evaluate_residuals(inputs, outputs, residuals)
```

User defined method to evaluate residuals

*Example*

.. code-block:: python

    def evaluate_residuals(self, inputs, outputs, residuals):
        x = outputs['x']
        a = inputs['a']
        b = inputs['b']
        c = inputs['c']
        residuals['x'] = a * x**2 + b * x + c

<a id="csdl.core.custom_implicit_operation.CustomImplicitOperation.compute_derivatives"></a>

### compute\_derivatives

```python
def compute_derivatives(inputs, outputs, derivatives)
```

[Optional] User defined method to evaluate exact derivatives of
residuals wrt inputs and outputs

*Example*

.. code-block:: python

    def compute_derivatives(self, inputs, outputs, derivatives):
        a = inputs['a']
        b = inputs['b']
        x = outputs['x']

        derivatives['x', 'a'] = x**2
        derivatives['x', 'b'] = x
        derivatives['x', 'c'] = 1.0
        derivatives['x', 'x'] = 2 * a * x + b

        # only necessary if implementing `apply_inverse_jacobian`
        self.inv_jac = 1.0 / (2 * a * x + b)

<a id="csdl.core.custom_implicit_operation.CustomImplicitOperation.solve_residual_equations"></a>

### solve\_residual\_equations

```python
def solve_residual_equations(inputs, outputs)
```

[Optional] User defined method to solve residual equations,
computing the outputs given the inputs. Define this method to
implement a custom solver. Assigning a nonlinear solver will
cause `evaluate_residual_equations` to run instead.

*Example*

.. code-block:: python

    def solve_residual_equations(self, inputs, outputs):
        a = inputs['a']
        b = inputs['b']
        c = inputs['c']
        outputs['x'] = (-b + (b ** 2 - 4 * a * c) ** 0.5) / (2 * a)

<a id="csdl.core.custom_implicit_operation.CustomImplicitOperation.apply_inverse_jacobian"></a>

### apply\_inverse\_jacobian

```python
def apply_inverse_jacobian(d_outputs, d_residuals, mode)
```

[Optional] Solve linear system. Invoked when solving coupled
linear system; i.e. when solving Newton system to update
implicit state variables, and when computing total derivatives

*Example*

.. code-block:: python

    # using self.inv_jac defined in `compute_derivatives` example
    def apply_inverse_jacobian( self, d_outputs, d_residuals, mode)
        if mode == 'fwd':
            d_outputs['x'] = self.inv_jac * d_residuals['x']
        elif mode == 'rev':
            d_residuals['x'] = self.inv_jac * d_outputs['x']

<a id="csdl.core.custom_implicit_operation.CustomImplicitOperation.compute_jacvec_product"></a>

### compute\_jacvec\_product

```python
def compute_jacvec_product(inputs, outputs, d_inputs, d_outputs, d_residuals, mode)
```

[Optional] Implement partial derivatives by computing a
matrix-vector product.

*Example*

.. code-block:: python

    def compute_jacvec_product(
            self,
            inputs,
            outputs,
            d_inputs,
            d_outputs,
            d_residuals,
            mode,
        ):
            a = inputs['a']
            b = inputs['b']
            c = inputs['c']
            x = outputs['x']
            if mode == 'fwd':
                if 'x' in d_residuals:
                    if 'x' in d_outputs:
                        d_residuals['x'] += (2 * a * x + b) * d_outputs['x']
                    if 'a' in d_inputs:
                        d_residuals['x'] += x ** 2 * d_inputs['a']
                    if 'b' in d_inputs:
                        d_residuals['x'] += x * d_inputs['b']
                    if 'c' in d_inputs:
                        d_residuals['x'] += d_inputs['c']
            elif mode == 'rev':
                if 'x' in d_residuals:
                    if 'x' in d_outputs:
                        d_outputs['x'] += (2 * a * x + b) * d_residuals['x']
                    if 'a' in d_inputs:
                        d_inputs['a'] += x ** 2 * d_residuals['x']
                    if 'b' in d_inputs:
                        d_inputs['b'] += x * d_residuals['x']
                    if 'c' in d_inputs:
                        d_inputs['c'] += d_residuals['x']




<a id="csdl.core.node"></a>

# csdl.core.node

<a id="csdl.core.node.slice_to_tuple"></a>

### slice\_to\_tuple

```python
def slice_to_tuple(key: slice, size: int) -> tuple
```

<a id="csdl.core.node.Node"></a>

## Node Objects

```python
class Node()
```

The ``Node`` class is a base type for nodes in a Directed
Acyclic Graph (DAG) that represents the computation to be performed
during model evaluation.

<a id="csdl.core.node.Node.__init__"></a>

### \_\_init\_\_

```python
def __init__(*args, **kwargs)
```

<a id="csdl.core.node.Node.__iadd__"></a>

### \_\_iadd\_\_

```python
def __iadd__(other)
```

<a id="csdl.core.node.Node.__iand__"></a>

### \_\_iand\_\_

```python
def __iand__(other)
```

<a id="csdl.core.node.Node.__idiv__"></a>

### \_\_idiv\_\_

```python
def __idiv__(other)
```

<a id="csdl.core.node.Node.__ifloordiv__"></a>

### \_\_ifloordiv\_\_

```python
def __ifloordiv__(other)
```

<a id="csdl.core.node.Node.__ilshift__"></a>

### \_\_ilshift\_\_

```python
def __ilshift__(other)
```

<a id="csdl.core.node.Node.__imod__"></a>

### \_\_imod\_\_

```python
def __imod__(other)
```

<a id="csdl.core.node.Node.__imul__"></a>

### \_\_imul\_\_

```python
def __imul__(other)
```

<a id="csdl.core.node.Node.__ior__"></a>

### \_\_ior\_\_

```python
def __ior__(other)
```

<a id="csdl.core.node.Node.__ipow__"></a>

### \_\_ipow\_\_

```python
def __ipow__(other)
```

<a id="csdl.core.node.Node.__irshift__"></a>

### \_\_irshift\_\_

```python
def __irshift__(other)
```

<a id="csdl.core.node.Node.__isub__"></a>

### \_\_isub\_\_

```python
def __isub__(other)
```

<a id="csdl.core.node.Node.__ixor__"></a>

### \_\_ixor\_\_

```python
def __ixor__(other)
```

<a id="csdl.core.node.Node.add_fwd_edges"></a>

### add\_fwd\_edges

```python
def add_fwd_edges()
```

<a id="csdl.core.node.Node.remove_fwd_edges"></a>

### remove\_fwd\_edges

```python
def remove_fwd_edges()
```

Remove fwd edges so that we can update the graph.
This is *only* used when exposing intermediate variables for a
composite residual.

<a id="csdl.core.node.Node.remove_dependencies"></a>

### remove\_dependencies

```python
def remove_dependencies()
```

Remove bwd edges so that we can update the graph.
This is *only* used when exposing intermediate variables for a
composite residual.

<a id="csdl.core.node.Node.add_dependent_node"></a>

### add\_dependent\_node

```python
def add_dependent_node(dependent)
```

<a id="csdl.core.node.Node.register_nodes"></a>

### register\_nodes

```python
def register_nodes(nodes: dict)
```

Register all nodes in DAG.

**Parameters**

nodes: dict[Variable]
    Dictionary of nodes registered so far

<a id="csdl.core.node.Node.incr_times_visited"></a>

### incr\_times\_visited

```python
def incr_times_visited()
```

Increment number of times a node is visited during ``topological_sort``.
This is necessary for ``topological_sort`` to determine
execution order for expressions.

<a id="csdl.core.node.Node.get_dependency_index"></a>

### get\_dependency\_index

```python
def get_dependency_index(candidate) -> Optional[int]
```

Get index of dependency in ``self.dependencies``. Used for
removing indirect dependencies that woud otherwise affect the
cost of branches in the DAG, which would affect execution order,
even with the sme constraints on execution order.

**Parameters**

candidate: Variable
    The candidate dependency node

**Returns**

Optional[int]
    If ``dependency`` is a dependency of ``self``, then the index of
    ``dependency`` in ``self.dependencies`` is returned. Otherwise,
    ``None`` is returned.

<a id="csdl.core.node.Node.remove_dependency_by_index"></a>

### remove\_dependency\_by\_index

```python
def remove_dependency_by_index(index)
```

Remove dependency node, given its index. does nothing if
``index`` is out of range. See
``Variable.remove_dependency``.

**Parameters**

index: int
    Index within ``self.dependencies`` where the node to be
    removed might be

<a id="csdl.core.node.Node.remove_dependency_node"></a>

### remove\_dependency\_node

```python
def remove_dependency_node(candidate)
```

Remove dependency node. Does nothing if `candidate` is not a
dependency. Used for removing indirect dependencies and
preventing cycles from forming in DAG.

**Parameters**

candidate: Variable
    Node to remove from ``self.dependencies``

<a id="csdl.core.node.Node.get_dependent_index"></a>

### get\_dependent\_index

```python
def get_dependent_index(candidate) -> Optional[int]
```

Get index of dependency in ``self.dependencies``. Used for
removing indirect dependencies that woud otherwise affect the
cost of branches in the DAG, which would affect execution order,
even with the sme constraints on execution order.

**Parameters**

candidate: Variable
    The candidate dependency node

**Returns**

Optional[int]
    If ``dependency`` is a dependency of ``self``, then the index of
    ``dependency`` in ``self.dependencies`` is returned. Otherwise,
    ``None`` is returned.

<a id="csdl.core.node.Node._dedup_dependencies"></a>

### \_dedup\_dependencies

```python
def _dedup_dependencies()
```

Remove duplicate dependencies. Used when adding a dependency.

<a id="csdl.core.node.Node.remove_dependent_by_index"></a>

### remove\_dependent\_by\_index

```python
def remove_dependent_by_index(index)
```

Remove dependency node, given its index. does nothing if
``index`` is out of range. See
``Variable.remove_dependency``.

**Parameters**

index: int
    Index within ``self.dependencies`` where the node to be
    removed might be

<a id="csdl.core.node.Node.remove_dependent_node"></a>

### remove\_dependent\_node

```python
def remove_dependent_node(candidate)
```

Remove dependency node. Does nothing if `candidate` is not a
dependency. Used for removing indirect dependencies and
preventing cycles from forming in DAG.

**Parameters**

candidate: Variable
    Node to remove from ``self.dependencies``

<a id="csdl.core.node.Node.print_dag"></a>

### print\_dag

```python
def print_dag(depth=-1, indent='')
```

Print the graph starting at this node (debugging tool)

<a id="csdl.core.node.Node.get_num_dependents"></a>

### get\_num\_dependents

```python
def get_num_dependents()
```




<a id="csdl.core.variable"></a>

# csdl.core.variable

<a id="csdl.core.variable.slice_to_tuple"></a>

### slice\_to\_tuple

```python
def slice_to_tuple(key: slice, size: int) -> tuple
```

<a id="csdl.core.variable.Variable"></a>

## Variable Objects

```python
class Variable(Node)
```

<a id="csdl.core.variable.Variable.__init__"></a>

### \_\_init\_\_

```python
def __init__(name, val=1.0, shape=(1, ), src_indices=None, flat_src_indices=None, units=None, desc='', tags=None, shape_by_conn=False, copy_shape=None, distributed=None, *args, **kwargs, *, ,)
```

<a id="csdl.core.variable.Variable.__pos__"></a>

### \_\_pos\_\_

```python
def __pos__()
```

<a id="csdl.core.variable.Variable.__neg__"></a>

### \_\_neg\_\_

```python
def __neg__()
```

<a id="csdl.core.variable.Variable.__add__"></a>

### \_\_add\_\_

```python
def __add__(other)
```

<a id="csdl.core.variable.Variable.__sub__"></a>

### \_\_sub\_\_

```python
def __sub__(other)
```

<a id="csdl.core.variable.Variable.__mul__"></a>

### \_\_mul\_\_

```python
def __mul__(other)
```

<a id="csdl.core.variable.Variable.__truediv__"></a>

### \_\_truediv\_\_

```python
def __truediv__(other)
```

<a id="csdl.core.variable.Variable.__pow__"></a>

### \_\_pow\_\_

```python
def __pow__(other)
```

<a id="csdl.core.variable.Variable.__radd__"></a>

### \_\_radd\_\_

```python
def __radd__(other)
```

<a id="csdl.core.variable.Variable.__rsub__"></a>

### \_\_rsub\_\_

```python
def __rsub__(other)
```

<a id="csdl.core.variable.Variable.__rmul__"></a>

### \_\_rmul\_\_

```python
def __rmul__(other)
```

<a id="csdl.core.variable.Variable.__rtruediv__"></a>

### \_\_rtruediv\_\_

```python
def __rtruediv__(other)
```

<a id="csdl.core.variable.Variable.__getitem__"></a>

### \_\_getitem\_\_

```python
def __getitem__(key: Union[int, slice, Tuple[slice]])
```

<a id="csdl.core.variable.Variable.add_dependency_node"></a>

### add\_dependency\_node

```python
def add_dependency_node(dependency)
```




<a id="csdl.core.output"></a>

# csdl.core.output

<a id="csdl.core.output.Output"></a>

## Output Objects

```python
class Output(Variable)
```

Base class for outputs; used to prevent circular imports

<a id="csdl.core.output.Output.__init__"></a>

### \_\_init\_\_

```python
def __init__(name, val=1.0, shape=(1, ), src_indices=None, flat_src_indices=None, units=None, desc='', tags=None, shape_by_conn=False, copy_shape=None, distributed=None, op=None, res_units=None, lower=None, upper=None, ref=1.0, ref0=0.0, res_ref=1.0, *args, **kwargs, *, ,)
```




<a id="csdl.core.concatenation"></a>

# csdl.core.concatenation

<a id="csdl.core.concatenation.Concatenation"></a>

## Concatenation Objects

```python
class Concatenation(Output)
```

Class for creating an explicit output

<a id="csdl.core.concatenation.Concatenation.__init__"></a>

### \_\_init\_\_

```python
def __init__(name, val=1.0, shape: Tuple[int] = (1, ), units=None, desc='', tags=None, shape_by_conn=False, copy_shape=None, res_units=None, lower=None, upper=None, ref=1.0, ref0=0.0, res_ref=1.0, *args, **kwargs, *, ,)
```

Initialize explicit output

**Parameters**

name: str
    Name of variable to compute explicitly
shape: Tuple[int]
    Shape of variable to compute explicitly
val: Number or ndarray
    Initial value of variable to compute explicitly

<a id="csdl.core.concatenation.Concatenation.__setitem__"></a>

### \_\_setitem\_\_

```python
def __setitem__(key: Union[int, slice, Tuple[slice]], var: Variable)
```




<a id="csdl.core.operation"></a>

# csdl.core.operation

<a id="csdl.core.operation.Operation"></a>

## Operation Objects

```python
class Operation(Node)
```

<a id="csdl.core.operation.Operation.__init__"></a>

### \_\_init\_\_

```python
def __init__(*args, **kwargs, *, ,)
```

<a id="csdl.core.operation.Operation.add_dependency_node"></a>

### add\_dependency\_node

```python
def add_dependency_node(dependency)
```




<a id="csdl.core.standard_operation"></a>

# csdl.core.standard\_operation

<a id="csdl.core.standard_operation.StandardOperation"></a>

## StandardOperation Objects

```python
class StandardOperation(Operation)
```

<a id="csdl.core.standard_operation.StandardOperation.__init__"></a>

### \_\_init\_\_

```python
def __init__(*args, **kwargs)
```

<a id="csdl.core.standard_operation.StandardOperation.define_compute_strings"></a>

### define\_compute\_strings

```python
def define_compute_strings()
```




<a id="csdl.core.custom_operation"></a>

# csdl.core.custom\_operation

<a id="csdl.core.custom_operation.CustomOperation"></a>

## CustomOperation Objects

```python
class CustomOperation(Operation)
```

<a id="csdl.core.custom_operation.CustomOperation.__init__"></a>

### \_\_init\_\_

```python
def __init__(*args, **kwargs)
```

<a id="csdl.core.custom_operation.CustomOperation.initialize"></a>

### initialize

```python
def initialize()
```

User defined method to declare parameter values. Parameters are
compile time constants (neither inputs nor outputs to the model)
and cannot be updated at runtime. Parameters are intended to
make a ``CustomOperation`` subclass definition generic, and therefore
reusable. The example below shows how a ``CustomOperation`` subclass
definition uses parameters and how the user can set parameters
when constructing the example ``CustomOperation`` subclass. Note
that the user never instantiates nor inherits directly from the
``CustomOperation`` base class.

**Example**

.. code-block:: python

    # in this example, we inherit from ExplicitOperation, but
    # the user can also inherit from ImplicitOperation
    class Example(ExplicitOperation):
        def initialize(self):
            self.parameters.declare('in_name', types=str)
            self.parameters.declare('out_name', types=str)

        def define(self):
            # use parameters declared in ``initialize``
            in_name = self.parameters['in_name']
            out_name = self.parameters['out_name']

            self.add_input(in_name)
            self.add_output(out_name)
            self.declare_derivatives(out_name, in_name)

        # define run time behavior by defining other methods...

    # compile using Simulator imported from back end...
    sim = Simulator(
        Example(
            in_name='x',
            out_name='y',
        ),
    )

<a id="csdl.core.custom_operation.CustomOperation.define"></a>

### define

```python
def define()
```

User defined method to define custom operation

**Example**

.. code-block:: python

    def define(self):
        self.add_input('Cl')
        self.add_input('Cd')
        self.add_input('rho')
        self.add_input('V')
        self.add_input('S')
        self.add_output('L')
        self.add_output('D')

        # declare derivatives of all outputs wrt all inputs
        self.declare_derivatives('*', '*'))

<a id="csdl.core.custom_operation.CustomOperation.add_input"></a>

### add\_input

```python
def add_input(name, val=1.0, shape=None, src_indices=None, flat_src_indices=None, units=None, desc='', tags=None, shape_by_conn=False, copy_shape=None)
```

Add an input to this operation.

**Example**

.. code-block:: python

    class Example(ExplicitOperation):
        def define(self):
            self.add_input('Cl')
            self.add_input('Cd')
            self.add_input('rho')
            self.add_input('V')
            self.add_input('S')
            self.add_output('L')
            self.add_output('D')

        # ...

    class Example(ImplicitOperation):
        def define(self):
            self.add_input('a', val=1.)
            self.add_input('b', val=-4.)
            self.add_input('c', val=3.)
            self.add_output('x', val=0.)

        # ...

<a id="csdl.core.custom_operation.CustomOperation.add_output"></a>

### add\_output

```python
def add_output(name, val=1.0, shape=None, units=None, res_units=None, desc='', lower=None, upper=None, ref=1.0, ref0=0.0, res_ref=1.0, tags=None, shape_by_conn=False, copy_shape=None)
```

Add an output to this operation.

**Example**

.. code-block:: python

    class Example(ExplicitOperation):
        def define(self):
            self.add_input('Cl')
            self.add_input('Cd')
            self.add_input('rho')
            self.add_input('V')
            self.add_input('S')
            self.add_output('L')
            self.add_output('D')

        # ...

    class Example(ImplicitOperation):
        def define(self):
            self.add_input('a', val=1.)
            self.add_input('b', val=-4.)
            self.add_input('c', val=3.)
            self.add_output('x', val=0.)

        # ...

<a id="csdl.core.custom_operation.CustomOperation.declare_derivatives"></a>

### declare\_derivatives

```python
def declare_derivatives(of, wrt, dependent=True, rows=None, cols=None, val=None, method='exact', step=None, form=None, step_calc=None)
```

Declare partial derivatives of each output with respect to each
input (ExplicitOperation) or each residual associated with an output with
respect to the input/output (ImplicitOperation).

.. code-block:: python

    class Example(ExplicitOperation):
        def define(self):
            self.add_input('Cl')
            self.add_input('Cd')
            self.add_input('rho')
            self.add_input('V')
            self.add_input('S')
            self.add_output('L')
            self.add_output('D')

            # declare derivatives of all outputs wrt all inputs
            self.declare_derivatives('*', '*')

        # ...

    class Example(ImplicitOperation):
        def define(self):
            self.add_input('a', val=1.)
            self.add_input('b', val=-4.)
            self.add_input('c', val=3.)
            self.add_output('x', val=0.)
            # declare derivative of residual associated with x
            # wrt x
            self.declare_derivatives('x', 'x')
            # declare derivative of residual associated with x
            # wrt a, b, c
            self.declare_derivatives('x', ['a','b','c'])

            self.linear_solver = ScipyKrylov()
            self.nonlinear_solver = NewtonSolver(solve_subsystems=False)

        # ...




<a id="csdl.core.subgraph"></a>

# csdl.core.subgraph

<a id="csdl.core.subgraph.Subgraph"></a>

## Subgraph Objects

```python
class Subgraph(Node)
```

Class for declaring an input variable

<a id="csdl.core.subgraph.Subgraph.__init__"></a>

### \_\_init\_\_

```python
def __init__(name: str, submodel, *args, *, promotes=None, promotes_inputs=None, promotes_outputs=None, min_procs=1, max_procs=None, proc_weight=1.0, **kwargs, ,)
```

<a id="csdl.core.subgraph.Subgraph.add_dependency_node"></a>

### add\_dependency\_node

```python
def add_dependency_node(dependency)
```

